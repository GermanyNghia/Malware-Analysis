.386
include \masm32\include\masm32rt.inc
includelib \masm32\lib\masm32rt.lib
ASSUME FS:NOTHING



.code

    jmp main 
    func1  db"user32.dll",0
    func2 db "MessageBoxA",0
    caption db "Hello",0
    message db "World!",0

main:
call Delta
Delta:
    pop ebp
    sub ebp, offset Delta
mov eax, fs:30h
mov eax, [eax + 0Ch] 
mov eax, [eax + 14h]
mov eax, [eax]		
mov eax, [eax]		
mov eax, [eax + 10h]

mov ecx, eax

push	ebx
push	esi

test	ecx, ecx
jz		nothing

mov		eax, [ecx + 3Ch]        ; e_lfanew
lea		eax, [eax + ecx + 78h]  ; eax = IMAGE_DATA_DIRECTORY for IMAGE_DIRECTORY_ENTRY_EXPORT

mov		edx, [eax]              ; edx = VirtualAddress
lea		eax, [ecx + edx]        ; eax = IMAGE_EXPORT_DIRECTORY

mov		edx, [eax + 18h]        ; rdx = NumberOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, NumberOfNames);
test	edx, edx
jz		nothing

mov		ebx, [eax + 20h]        ; ebx = AddressOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfNames);
lea		ebx, [ecx + ebx]

one:
	mov		esi, [ebx]
	lea		esi, [ecx + esi]        ; function name

	cmp		dword ptr [esi], 64616f4ch          ; Load
	jnz		two
	cmp		dword ptr [esi + 4], 7262694ch      ; Libr
	jnz		two
	cmp		dword ptr [esi + 8], 0041797261h      ; aryA
	jnz		two

	; Found our function
	neg		edx
	mov		esi, [eax + 18h]        ; esi = NumberOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, NumberOfNames);
	lea		edx, [esi + edx]        ; edx = function index

	mov		esi, [eax + 24h]        ; r10 = AddressOfNameOrdinals ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfNameOrdinals);

	lea		esi, [ecx + esi]
	movzx	edx, word ptr [esi + edx * 2]   ; edx = index in the function table

	mov		esi, [eax + 1Ch]        ; esi = AddressOfFunctions ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfFunctions);
	lea		esi, [ecx + esi]

	mov		esi, [esi + edx * 4]    ; esi = offset of possible func addr

	; Check for forwarded function
	mov		edx, [eax]              ; edx = VirtualAddress ---- size_t offset = offsetof(IMAGE_DATA_DIRECTORY, VirtualAddress);
	cmp		esi, edx
	jb		nothing

	mov		ebx, [eax + 4]          ; ebx = Size ---- size_t offset = offsetof(IMAGE_DATA_DIRECTORY, Size);
	add		ebx, edx
	cmp		esi, ebx
	jae		nothing

	lea		eax, [ecx + esi]        ; Got our func addr!
      jmp loadLib
	pop		esi
	pop		ebx
	ret

two:
	add		ebx, 4
	dec		edx
	jnz		one


nothing:
	xor		eax, eax

	pop		esi
	pop		ebx
	ret

loadLib:
       ; func1 == 0101F002 401002
      mov edx, ebp
      add edx , offset func1
      push edx
      call eax
      push eax
        

	push	ebx
	push	esi

	test	ecx, ecx
	jz		nothing

	mov		eax, [ecx + 3Ch]        ; e_lfanew
	lea		eax, [eax + ecx + 78h]  ; eax = IMAGE_DATA_DIRECTORY for IMAGE_DIRECTORY_ENTRY_EXPORT

	mov		edx, [eax]              ; edx = VirtualAddress
	lea		eax, [ecx + edx]        ; eax = IMAGE_EXPORT_DIRECTORY

	mov		edx, [eax + 18h]        ; rdx = NumberOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, NumberOfNames);
	test	edx, edx
	jz		nothing

	mov		ebx, [eax + 20h]        ; ebx = AddressOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfNames);
	lea		ebx, [ecx + ebx]
      jmp getPorcAddr
          
getPorcAddr:
      mov		esi, [ebx]
	lea		esi, [ecx + esi]        ; function name

	cmp		dword ptr [esi], 50746547h          ; GetP
	jnz		three
	cmp		dword ptr [esi + 4], 41636f72h      ; rocA
	jnz		three
	cmp		dword ptr [esi + 8], 65726464h      ; ddre
	jnz		three
	cmp		dword ptr [esi + 11], 00737365h     ; ress\0
	jnz		three     
	; Found our function
	neg		edx
	mov		esi, [eax + 18h]        ; esi = NumberOfNames ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, NumberOfNames);
	lea		edx, [esi + edx]        ; edx = function index

	mov		esi, [eax + 24h]        ; r10 = AddressOfNameOrdinals ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfNameOrdinals);

	lea		esi, [ecx + esi]
	movzx	edx, word ptr [esi + edx * 2]   ; edx = index in the function table

	mov		esi, [eax + 1Ch]        ; esi = AddressOfFunctions ---- size_t offset = offsetof(IMAGE_EXPORT_DIRECTORY, AddressOfFunctions);
	lea		esi, [ecx + esi]

	mov		esi, [esi + edx * 4]    ; esi = offset of possible func addr

	; Check for forwarded function
	mov		edx, [eax]              ; edx = VirtualAddress ---- size_t offset = offsetof(IMAGE_DATA_DIRECTORY, VirtualAddress);
	cmp		esi, edx
	jb		nothing

	mov		ebx, [eax + 4]          ; ebx = Size ---- size_t offset = offsetof(IMAGE_DATA_DIRECTORY, Size);
	add		ebx, edx
	cmp		esi, ebx
	jae		nothing

	lea		eax, [ecx + esi]        ; Got our func addr!
      jmp proccAdd
	ret

three:
	add		ebx, 4
	dec		edx
	jnz		getPorcAddr

proccAdd:
      mov         edx, eax
      pop         eax
	pop		esi
	pop		ebx; load lib (user32.dll)
      mov eax, ebp
      add eax, offset func2 ; func == 0101F00D
      push eax; eax "MessageBoxA"
      push        ebx
      call        edx
      jmp messageBox
messageBox:
      push 0
      mov edx, ebp
      add edx , offset caption; caption == 0101F019
      push edx
      mov edx, ebp
      add edx , offset message
      push edx ; message == 0101F01F
      push 0
      call eax
      push 01012475h
      pop eax
      jmp eax ; jump to OEP

end main